<!--
***********************************************************************************************
Microsoft.NET.Sdk.Razor.StaticWebAssets.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->

<Project ToolsVersion="14.0">

  <!-- Targets that support static content scenarios in ASP.NET Core.
       The main targets are:
       * GenerateStaticWebAssetsManifest: Creates a manifest file to use in development with
         the paths to all the references packages and projects content roots.
       * ResolveStaticWebAssetsInputs: Collects all the static assets from different sources
         * Current project.
         * Referenced project.
         * Referenced packages.
  -->

  <UsingTask
    TaskName="Microsoft.AspNetCore.Razor.Tasks.GenerateStaticWebAssetsManifest"
    AssemblyFile="$(RazorSdkBuildTasksAssembly)"
    Condition="'$(RazorSdkBuildTasksAssembly)' != ''" />

  <UsingTask
    TaskName="Microsoft.AspNetCore.Razor.Tasks.GetDefaultStaticWebAssetsBasePath"
    AssemblyFile="$(RazorSdkBuildTasksAssembly)"
    Condition="'$(RazorSdkBuildTasksAssembly)' != ''" />

  <PropertyGroup>
    <GenerateStaticWebAssetsManifestDependsOn>
      ResolveStaticWebAssetsInputs;
      _CreateStaticWebAssetsInputsCacheFile;
      $(GenerateStaticWebAssetsManifestDependsOn)
    </GenerateStaticWebAssetsManifestDependsOn>

    <GetCurrentProjectStaticWebAssetsDependsOn>
      ResolveStaticWebAssetsInputs;
      $(GetCurrentProjectStaticWebAssetsDependsOn)
    </GetCurrentProjectStaticWebAssetsDependsOn>

    <AssignTargetPathsDependsOn>
      GenerateStaticWebAssetsManifest;
      $(AssignTargetPathsDependsOn)
    </AssignTargetPathsDependsOn>

    <ResolveStaticWebAssetsInputsDependsOn>
      _ResolveStaticWebAssetsProjectReferences;
      $(ResolveStaticWebAssetsInputsDependsOn)
    </ResolveStaticWebAssetsInputsDependsOn>

  </PropertyGroup>

  <PropertyGroup>
    <_GeneratedStaticWebAssetsInputsCacheFile>$(IntermediateOutputPath)$(TargetName).StaticWebAssets.cache</_GeneratedStaticWebAssetsInputsCacheFile>
    <_GeneratedStaticWebAssetsDevelopmentManifest>$(IntermediateOutputPath)$(TargetName).StaticWebAssets.xml</_GeneratedStaticWebAssetsDevelopmentManifest>
  </PropertyGroup>

  <Target 
    Name="_CreateStaticWebAssetsInputsCacheFile"
    DependsOnTargets="ResolveStaticWebAssetsInputs">
    
    <ItemGroup>
      <!-- 
      This is the list of inputs that will be used for generating the manifest used during development. 
      -->
      <_ExternalStaticWebAsset
        Include="%(StaticWebAsset.Identity)"
        Condition="'%(SourceType)' != ''">
          <BasePath>%(StaticWebAsset.BasePath)</BasePath>
          <ContentRoot>%(StaticWebAsset.ContentRoot)</ContentRoot>
      </_ExternalStaticWebAsset>
    </ItemGroup>

    <!-- We need a transform here to make sure we hash the metadata -->
    <Hash ItemsToHash="@(_ExternalStaticWebAsset->'%(Identity)%(BasePath)%(ContentRoot)')">
      <Output TaskParameter="HashResult" PropertyName="_StaticWebAssetsCacheHash" />
    </Hash>

    <WriteLinesToFile 
      Lines="$(_StaticWebAssetsCacheHash)" 
      File="$(_GeneratedStaticWebAssetsInputsCacheFile)" 
      Overwrite="True" 
      WriteOnlyWhenDifferent="True" />

    <ItemGroup>
      <FileWrites Include="$(_GeneratedStaticWebAssetsInputsCacheFile)" />
    </ItemGroup>

  </Target>

  <!-- 
    This target generates a manifest for development time that includes information
    about the base path for the referenced package and project static web assets. The
    manifest includes the content root and the base path for each of the referenced
    packages and projects.

    Ideally, each package/project contains a unique base path and a given content
    root, but we don't check for duplicates on either of them.
     -->

  <Target 
    Name="GenerateStaticWebAssetsManifest"
    Inputs="$(_GeneratedStaticWebAssetsInputsCacheFile)"
    Outputs="$(_GeneratedStaticWebAssetsDevelopmentManifest)"
    DependsOnTargets="$(GenerateStaticWebAssetsManifestDependsOn)">
  
    <GenerateStaticWebAssetsManifest 
      ContentRootDefinitions="@(_ExternalStaticWebAsset)"
      TargetManifestPath="$(_GeneratedStaticWebAssetsDevelopmentManifest)" />
  
      <!-- This is the list of inputs that will be used for generating the manifest used during development. -->
    <ItemGroup>
      <EmbeddedResource Condition="'@(_ExternalStaticWebAsset->Count())' != '0'"
        Include="$(_GeneratedStaticWebAssetsDevelopmentManifest)"
        LogicalName="Microsoft.AspNetCore.StaticWebAssets.xml" />
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="$(_GeneratedStaticWebAssetsDevelopmentManifest)" />
    </ItemGroup>

  </Target>

  <!-- This target collects all the StaticWebAssets from different sources:
       * The current project StaticWebAssets that come from wwwroot\** by default.
       * Assets from referenced projects that get retrieved invoking an MSBuild target on
         the referenced projects.
       * Assets from the referenced packages. These will be implicitly included when nuget
         restores the package and includes the package props file for the package.
  -->
  <Target 
    Name="ResolveStaticWebAssetsInputs"
    DependsOnTargets="$(ResolveStaticWebAssetsInputsDependsOn)">

    <!-- StaticWebAssets from the current project -->

    <!-- Computes a default safe base path from the $(PackageId) that will be a prefix
         to all the resources being exported from this library by default. The convention
         consists of removing intermediate whitespaces, dots and lower casing all letters
         in the package id using an invariant culture.

         We don't aim to handle all possible cases for this prefix, as it can get really
         complicated (non-unicode characters for example), so for that case,
         StaticWebAssetBasePath can be set explicitly and we won't interfere.
    -->
    <GetDefaultStaticWebAssetsBasePath
      BasePath="$(PackageId)"
      Condition="'$(StaticWebAssetBasePath)' == ''">
      <Output TaskParameter="SafeBasePath" PropertyName="_StaticWebAssetSafeBasePath" />
    </GetDefaultStaticWebAssetsBasePath>

    <PropertyGroup>
      <StaticWebAssetBasePath Condition="$(StaticWebAssetBasePath) == ''">_content/$(_StaticWebAssetSafeBasePath)</StaticWebAssetBasePath>
    </PropertyGroup>

    <ItemGroup>

      <_ThisProjectStaticWebAsset
        Include="$(MSBuildProjectDirectory)\wwwroot\**"
        Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" />
      <!-- 
        Should we promote 'wwwroot\**'' to a property?
        We don't want to capture any content outside the content root, that's why we don't do
        @(Content) here.
      -->
      <StaticWebAsset Include="@(_ThisProjectStaticWebAsset)">
        <!-- (Package, Project, '' (CurrentProject)) -->
        <SourceType></SourceType>
        <!-- Identifier describing the source, the package id, the project name, empty for the current project.  -->
        <SourceId>$(PackageId)</SourceId>
        <!-- 
          Full path to the content root for the item:
          * For packages it corresponds to %userprofile%/.nuget/packages/<<PackageId>>/<<PackageVersion>>/razorContent
          * For referenced projects it corresponds to <<FullProjectRefPath>>/wwwroot
          * For the current projects it corresponds to $(MSBuildThisProjectFileDirectory)wwwroot\
        -->
        <ContentRoot>$(MSBuildProjectDirectory)\wwwroot\</ContentRoot>
        <!-- Subsection (folder) from the url space where content for this library will be served. -->
        <BasePath>$(StaticWebAssetBasePath)</BasePath>
        <!-- Relative path from the content root for the file. At publish time, we combine the BasePath + Relative
  path to determine the final path for the file. -->
        <RelativePath>%(RecursiveDir)%(FileName)%(Extension)</RelativePath>

      </StaticWebAsset>
    </ItemGroup>

    <!-- StaticWebAssets from referenced projects. -->

    <MSBuild
      Condition="'@(_StaticWebAssetsProjectReference->Count())' != '0'"
      Projects="@(_StaticWebAssetsProjectReference)"
      BuildInParallel="$(BuildInParallel)"
      ContinueOnError="!$(BuildingProject)"
      Targets="GetCurrentProjectStaticWebAssets"
      Properties="_StaticWebAssetsSkipDependencies=true"
      SkipNonexistentTargets="true">
      <Output TaskParameter="TargetOutputs" ItemName="_ReferencedProjectStaticWebAssets" />
    </MSBuild>

    <ItemGroup>
      <StaticWebAsset Include="@(_ReferencedProjectStaticWebAssets)" />
    </ItemGroup>

    <!-- StaticWebAssets from packages are already available, so we don't do anything. -->
  </Target>

  <!-- This is a helper task to compute the project references we need to invoke to retrieve
       the static assets for a given application. We do it this way so that we can
       pass additional build properties to compute the assets from the package when referenced
       as a project. For example, Identity uses this hook to extend the project reference and
       pass in the bootstrap version to use. 
  -->
  <Target Name="_ResolveStaticWebAssetsProjectReferences"
    DependsOnTargets="ResolveReferences"
    Condition="'$(_StaticWebAssetsSkipDependencies)' == ''">

    <ItemGroup>
      <_StaticWebAssetsProjectReference Include="%(ReferencePath.MSBuildSourceProjectFile)" />
    </ItemGroup>

  </Target>

  <!--
    Child target to retrieve content from referenced projects
   -->

  <Target Name="GetCurrentProjectStaticWebAssets"
    DependsOnTargets="$(GetCurrentProjectStaticWebAssetsDependsOn)"
    Returns="@(_ThisProjectStaticWebAssets)">

    <ItemGroup>
      <_ThisProjectStaticWebAssets
        Include="@(StaticWebAsset)"
        Condition="'%(StaticWebAsset.SourceType)' == ''">
        <SourceType>Project</SourceType>
      </_ThisProjectStaticWebAssets>
    </ItemGroup>

  </Target>

</Project>